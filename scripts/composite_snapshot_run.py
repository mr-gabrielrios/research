''' Import packages. '''
# Time packages
import cftime, datetime, time
# Numerical analysis packages
import numpy as np, random, scipy, numba
# Local data storage packages
import dill, os, pickle
# Data structure packages
import pandas as pd, xarray as xr
# Visualization tools
import cartopy, cartopy.crs as ccrs, matplotlib, matplotlib.pyplot as plt
# Local imports
import accessor, composite, composite_snapshots, derived, utilities, socket, visualization, tc_analysis, tc_processing, rotate

import importlib
importlib.reload(composite);
importlib.reload(composite_snapshots);
importlib.reload(utilities);
importlib.reload(tc_analysis);
importlib.reload(tc_processing);
importlib.reload(visualization);
importlib.reload(rotate);
importlib.reload(derived);
importlib.reload(composite_snapshots);
importlib.reload(visualization);

def available_snapshot_counter(model, experiment, field, storm_type, intensity_bin, compositing_method):
    ''' Method to count the number of available snapshots for a given set of specifications. '''

    # Define the directory name containing the snapshots
    dirname = '/projects/GEOCLIM/gr7610/analysis/tc_storage/snapshots'
    # Initialize counter
    counter = 0
    # Set up dictionary holding flags for iterative checks
    flags = {'model': model,
             'experiment': '{0}-'.format(experiment),
             'field': field,
             'storm_type': storm_type,
             'intensity_bin': intensity_bin,
             'compositing_method': compositing_method}
    # Iterate over all files in the directory, and add every time all the flags are met
    for f in os.listdir(dirname):
        if sum([flags[k] in f for k in flags.keys()]) == len(flags):
            counter += 1
    
    print('{0:8}, {1:15}, {2:15}: {3} entries available.'.format(model, experiment, field, counter))

    return counter

def dataset_constructor(models, experiments, stacks, dx=0.5, dy=0.5, compositing_mode='planar', diagnostic=False):

    ''' 
    Method to construct xarray Datasets from numerical data generated by the snapshot stacking algorithm. 
    This results in data structures compatible with the composite_plot() method in visualization.py.

    The philosophy here is to:
    1. take three stacks of snapshots for a given model and field, with each stack corresponding to a different experiment and the third stack being their diference.
    2. get mean values for each stack
    3. construct a TC-centered domain around the stack for compatibility with xarray
    4. output a dataset for the given models and experiments holding data for the field
    '''

    if compositing_mode == 'azimuthal':
        dx = 0.9375

    # Initialize the data structure container
    dataset = {}
    # Iterate over each input model
    for model in models:
        dataset[model] = {}
        # Initialize model-specific sample size list.
        # This serves to populate the difference experiment with the minimum number of samples among previous experiments.
        sample_sizes = []
        # Iterate over each experiemnt
        for experiment in experiments:
            # Define the working numeric array that will be processed and output
            if '-' in experiment:
                # Get minimum number of sample sizes
                sample_size = int(np.min(sample_sizes))
                # This catches difference data that has already been compressed from stack to array form
                arr = stacks[model][experiment]
            else:
                # Get number of samples going into the composite mean
                sample_size = len(stacks[model][experiment])
                sample_sizes.append(sample_size)
                # This generates a composite mean over the snapshots
                arr = np.nanmean(stacks[model][experiment], axis=0)
            # Get the size of the resultant numeric array
            size_y, size_x = arr.shape
            if diagnostic:
                print('Number of x-elements: {0}; number of y-elements: {1}'.format(size_x, size_y))
            # Build the data structure depending on the compositing mode
            if compositing_mode == 'planar':
                dimension_name_x, dimension_name_y = 'grid_xt', 'grid_yt'
                # Get the center of the domain, with the index representing an approximate half-width of the domain
                center_y, center_x = int(size_y // 2), int(size_x // 2)
                if diagnostic:
                    print('Index of x-center: {0}; index of y-center: {1}'.format(center_x, center_y))
                # Define the coordinates as +/- half-width of the domain from the center
                # Note the -dx and -dy offsets. These allow for indexing fixes for pcolormesh, allowing the plots to center properly.
                coordinates_x = np.arange(-center_x*dx, center_x*dx, dx) - dx
                coordinates_y = np.arange(-center_y*dy, center_y*dy, dy) - dy
                if diagnostic:
                    print('x-coordinates: ', coordinates_x)
                    print('y-coordinates: ', coordinates_y)
                    
            elif compositing_mode == 'azimuthal':
                dimension_name_x, dimension_name_y = 'radius', 'pfull'
                pfull = np.array([110.419627, 141.09261 , 177.729388, 220.892397, 271.066624, 328.516337, 
                                  392.785273, 461.947262, 532.465907, 600.430867, 663.107383, 719.307118, 
                                  768.814284, 811.846869, 848.836021, 880.346139, 906.995722, 929.394583, 
                                  948.128523, 963.73257 , 976.687397, 987.392458, 996.109949])
                # This crudely assumes that the number of vertical levels is greater than the number of radial positions
                azimuthal_size_x = min(size_x, size_y)
                azimuthal_size_y = max(size_x, size_y)
                arr = arr.T if arr.shape[0] < arr.shape[1] else arr
                
                coordinates_x = np.arange(0, azimuthal_size_x*dx, dx)
                coordinates_y = pfull
                
                if diagnostic:
                    print('x-coordinates: ', coordinates_x.shape)
                    print('y-coordinates: ', coordinates_y.shape)

            # Fill nans with zeroes
            arr = np.where(np.isnan(arr), 0, arr)
            # Build the DataArray
            xarr = xr.DataArray(data=arr,
                                coords={dimension_name_y: ([dimension_name_y], coordinates_y),
                                        dimension_name_x: ([dimension_name_x], coordinates_x)},
                                attrs={'Sample size': sample_size})
                
            dataset[model][experiment] = xarr

    return dataset

def composite_snapshot_processor(models, experiments, field, compositing_method, storm_type='TS', intensity_bin='b1', experiment_reverse=False, diagnostic=True):
    
    ''' Note: experiment_reverse switches the order of provided experiments. '''
    
    snapshots = {}
    significance_masks = {}
    
    experiment_control, experiment_run = experiments
    experiment_difference = '{0}-{1}'.format(experiment_control, experiment_run) if experiment_reverse else '{1}-{0}'.format(experiment_control, experiment_run)
    for model in models:
        print('[composite_snapshot_processor()] Processing composites for {0}...'.format(model))
        stacks, lower_tail, median, upper_tail, significance_masking = composite_snapshots.main(mode='bootstrapping', model=model, experiments=experiments, field=field,
                                                                                                storm_type=storm_type, intensity_bin=intensity_bin, 
                                                                                                compositing_method=compositing_method, diagnostic=diagnostic)
        snapshots[model] = stacks
        snapshots[model][experiment_difference] = -median if experiment_reverse else median
        significance_masks[model] = np.where(significance_masking, 1, np.nan)
    
    experiments = [experiment_control, experiment_run, experiment_difference]

    dataset = dataset_constructor(models, experiments, snapshots, compositing_mode=compositing_method)

    return dataset, significance_masks, experiments

def composite_snapshot_plot(dataset, experiments, field, compositing_method, overlay=False, dataset_overlay=None, field_overlay=None, dpi=96, savefig=False):

    print(f'[composite_snapshot_plot] {experiments}')
    
    # Define plot metadata for saving, if needeed
    dpi = 300 if savefig else dpi
    dirname = '/tigress/GEOCLIM/gr7610/figs/swishe-small_scale'
    overlay_substring = '-overlay-{0}'.format(field_overlay) if overlay else ''

    # Plot base composites
    plot_type = 'azimuthal_2D' if compositing_method == 'azimuthal' else 'planar'
    plot_format = 'pcolormesh' if plot_type == 'planar' else 'contour'

    # If a figure is being saved, save two versions - one with statistics and stippling, one without
    figure_versions = {'statistics': True, 'publication': False}
    if savefig:
        for version, statistics_option in figure_versions.items():

            version_substring = 'version_{0}'.format(version)
            
            fig, gs, axes = visualization.composite_plot(dataset, models, experiments, field, plot_type=plot_type, 
                                                         format=plot_format, dpi=dpi, statistics=statistics_option)
            experiment_difference = experiments[-1]
        
            # Plot significance stippling
            if statistics_option:
                coordinate_x = 'grid_xt' if plot_type == 'planar' else 'radius'
                coordinate_y = 'grid_yt' if plot_type == 'planar' else 'pfull'
                for model_index, model in enumerate(models):
                    basis_vector_x, basis_vector_y = dataset[model][experiment_difference][coordinate_x], dataset[model][experiment_difference][coordinate_y]
                    X, Y = np.meshgrid(basis_vector_x, basis_vector_y)
                    axes['{0}, 2'.format(model_index)].scatter(X, Y, c=significance_masks[model].T, s=1, linewidth=1, marker='x', cmap='binary_r', alpha=0.5)
        
            # Fire this if the overlay flag is set and the accompanying data is provided
            if overlay and (dataset_overlay and field_overlay):
                fig_overlay, gs_overlay, axes_overlay = visualization.composite_plot(dataset_overlay, models, experiments, field=field_overlay, plot_type=plot_type, 
                                                                                     format=plot_format, overlay=True, parent_fig=(fig, gs, axes))

            filename = 'composite_mean-{0}{1}-{2}.png'.format(field, overlay_substring, version_substring)
            path = os.path.join(dirname, filename)
            print(path)
            plt.savefig(path, dpi=dpi, bbox_inches='tight')

    else:
        fig, gs, axes = visualization.composite_plot(dataset, models, experiments, field, plot_type=plot_type, 
                                                         format=plot_format, dpi=dpi, statistics=True)
        experiment_difference = experiments[-1]
    
        # Plot significance stippling
        coordinate_x = 'grid_xt' if plot_type == 'planar' else 'radius'
        coordinate_y = 'grid_yt' if plot_type == 'planar' else 'pfull'
        for model_index, model in enumerate(models):
            basis_vector_x, basis_vector_y = dataset[model][experiment_difference][coordinate_x], dataset[model][experiment_difference][coordinate_y]
            X, Y = np.meshgrid(basis_vector_x, basis_vector_y)
            axes['{0}, 2'.format(model_index)].scatter(X, Y, c=significance_masks[model].T, s=1, linewidth=1, marker='x', cmap='binary_r', alpha=0.5)
    
        # Fire this if the overlay flag is set and the accompanying data is provided
        if overlay and (dataset_overlay and field_overlay):
            fig_overlay, gs_overlay, axes_overlay = visualization.composite_plot(dataset_overlay, models, experiments, field=field_overlay, plot_type=plot_type, format=plot_format, overlay=True, parent_fig=(fig, gs, axes))

def main(models: list, fields: dict, overlay_field: str, savefig=False):

    models = ['HIRAM', 'AM2.5', 'FLOR']
    fields = {'WVP': 'planar', 'vi_h': 'planar'}
    overlay_field = None
    savefig = True
    
    experiment_reverse = True
    
    for field, compositing_method in fields.items():
        experiments = ['CTL1990s', 'CTL1990s_swishe']
        dataset, significance_masks, experiments = composite_snapshot_processor(models, experiments, field, compositing_method, storm_type='TS', intensity_bin='b1', experiment_reverse=experiment_reverse, diagnostic=False)
    
        if overlay_field:
            dataset_overlay, significance_masks_overlay, experiments = composite_snapshot_processor(models, experiments, overlay_field, compositing_method, storm_type='TS', intensity_bin='b1', experiment_reverse=experiment_reverse, diagnostic=False)
            composite_snapshot_plot(dataset, field, compositing_method=compositing_method, overlay=True, dataset_overlay=dataset_overlay, 
                                    field_overlay=overlay_field, savefig=savefig)
        else:
            composite_snapshot_plot(dataset, experiments, field, compositing_method=compositing_method, dpi=96, savefig=savefig)

            